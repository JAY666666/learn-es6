{"version":3,"sources":["variable.js"],"names":["x","y","console","log","z","c","h","k","a","i","b","o","foo","bar","tmp","ggg","fun1","add","tmp2","Date","fun2","tmp3","length","fun3","n","tmp4","tmp6","prop"],"mappings":"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","file":"variable.225ade06.js","sourceRoot":"../variable","sourcesContent":["//var定义的变量在全局范围内都有效,let定义的变量只在局部范围内有限\n//1 常规var定义变量\nvar x = y,\n    y = 'A';\nconsole.log(x + y); //undefinedA\n\nvar z = 'B',\n    c = z;\nconsole.log(z + c); //BB\n\n//2 for 语句的执行顺序(学习过程中的额外问题) 这两个for语句效果相同,下面一个为了方便了解for语句的真实执行顺序\nfor (var h = 0; h < 10; h++) {\n    console.log(h)\n}\n//(1)初始化变量(2)判断条件是否为true(3)true:执行代码块内的语句;false:跳出循环(4)最后的finaly-expression在判断条件之前执行\nvar k = 0;\nfor (;;) {\n    if (k > 9) break;\n    console.log(k);\n    k++\n}\n\n//3 对比,在for语句中var和let的对比\nvar a = [];\nfor (var i = 0; i < 10; i++) {\n    a[i] = function () {\n        console.log(i)\n    }\n}\na[6](); //10\na[7](); //10 在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10\n\nvar b = [];\nfor (let o = 0; o < 10; o++) {\n    b[o] = function () {\n        console.log(o)\n    }\n}\nb[6](); //6  变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6\nb[7](); //7\n\n//4 变量提升\nconsole.log(foo);\nvar foo = 1;\n//undefined var存在变量提升,相当于把var foo = undefined 提升到最前面,值不带过去\n\nconsole.log(bar);\nlet bar = 1;\n//referenceError bar is not defined  let不存在变量提升,所以bar is not defined\n\n//5 暂时性死区\nvar tmp = 123;\nif (true) {\n    console.log(tmp)\n    let tmp;\n} //undefined 因为let有暂时性死区,所以在if代码块中,tmp锁定了这个区域,所以外层定义的tmp不在此区域产生作用\n\nif (true) {\n    console.log(ggg); //referenceError\n    let ggg;\n    ggg = 1;\n    console.log(ggg); // 1\n}\n\n//6 不允许重复声明  不能在函数内部重新声明参数\nfunction fun1(add) {\n    //let add;  add can not repeat declare\n    let a = 1;\n    //var a = 2; 'a' has already been\n    console.log(a);\n}\nfun1();\n\n//7 (1)es5块级作用域  为什么需要块级作用域\n\nvar tmp2 = new Date();\n\nfunction fun2() {\n    console.log(tmp2)\n    if (false) {\n        var tmp2 = 'hello world';\n    }\n}\nfun2(); //undefined 函数内部的tmp2变量提升.覆盖到外部的变量\n\nvar tmp3 = 'hello';\nfor (var i = 0; i < tmp3.length; i++) {\n    console.log(tmp3[i]) // h e l l o\n}\nconsole.log(i) //5 变量i原本只是用来控制循环,但是循环结束之后,它并没有消失,泄露成了全部变量\n\n//7 (2)es6块级作用域\n\nfunction fun3() {\n    let n = 5;\n    if (true) {\n        n = 10;\n    }\n    console.log(5)\n}\nfun3(); // 5\n\n//8 const 声明一个只读的常量,一旦声明,无法改变,所以const声明时必须赋值,也不存在变量提升.不允许重复声明,存在暂存性死区\n\nconst tmp4 = 3;\nconsole.log(tmp4);\n// tmp4 = 4;\n// console.log(tmp4); Error tmp4 is read-only\n\n// const tmp5; \n// console.log(tmp5); SyntaxError: Missing initializer in const declaration\n\n// const本质,变量指向的那个内存地址不可变,但如对象,数组时,其对应地址中的数据结构就可以改变\nconst tmp6 = [];\ntmp6.prop = 123;\nconsole.log(tmp6); // [prop:123] 可添加数据结构\n// tmp6 = [123]; Error: tmp6 is read-only"]}